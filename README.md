# Latitude-Coding-Challenge

## Approach
My initial approach was to create three unit tests using the JUnit framework. I created one test for empty arrays, one for small arrays and one for large arrays. These were intended to test the accuracy as well as the efficiency of the arrays. 

When I did my first implementation of the algorithm I used an almost bruteforce algorithm. This algorithm would go through every element and calculate the possible profit of every subsequent integers in the array and then compare it with the current maximum profit. This means that algorithm becomes more complicated when there are more integers in the array. When I tested algorithm it passed all the unit tests, and the times taken to take the test were all 0 seconds, even for the large array. This meant that I could not compare these results with any algorithm that I created afterwards. So I created a much larger array that holds 1440 elements. 1440 is the number of minutes in 24 hour day, and since the algorithm is used to determine the maximum profit of yesterday's stock prices, this would be a good way to simulate the largest array size (Although most markets are not 24 hours). The resulting time I got from this was around 0.01 seconds.

I then created another algorithm. The new algorithm would only go though the array once, meaning that the complexity of the algorithm is linear, i.e. the algorithm running increases linearly with the size of the array. This new algorithm, first check if the array is null. It then checks if there is enough elements to make a trade. It then initialises a variable to represent the lowest price, and one to represent the maximum profit that can be made. It then goes through the array, and does several operations. First it checks if the current element is lower than the current lowest price and then updates the lowest price/ It then calculates the profit by subtracting the lowest price off the current element. It then compares it with the current maximum profit and updates it. It then moves on to the next element. Once its finished processing the array it will return the maximum profit that can be made. It is important in the algorithm that we check for the lowest price and then the profit while we are iterating through the loop as we do not want simply look for the lowest price and subtract that from the highest price, as the algorithm needs to make the purchase before the sale.

After running the tests all tests pass with 0 seconds taken for each. This means that this algorithm is faster than the my original algorithm. I also added in two more tests, one to check when its null and another that checks that the algorithm make the purchase first and then the sale, and is not simply getting the largest price and subtracting the lowest price.
